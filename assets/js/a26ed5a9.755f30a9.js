"use strict";(self.webpackChunknode_cli_docs=self.webpackChunknode_cli_docs||[]).push([[3114],{1802:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>c,toc:()=>l});var i=a(4848),r=a(8453);const t={title:"Tracing system",id:"trace-dispatcher",sidebar_position:1,keywords:["Get-started","run the node","installation","tracer","tracing","logging","cardano-node","cardano node"]},s="trace-dispatcher",c={id:"cardano-node/new-tracing-system/trace-dispatcher",title:"Tracing system",description:"efficient, simple and flexible program tracing",source:"@site/docs/cardano-node/new-tracing-system/tracedispatcher.md",sourceDirName:"cardano-node/new-tracing-system",slug:"/cardano-node/new-tracing-system/trace-dispatcher",permalink:"/documentation/cardano-node/new-tracing-system/trace-dispatcher",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cardano-node/new-tracing-system/tracedispatcher.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Tracing system",id:"trace-dispatcher",sidebar_position:1,keywords:["Get-started","run the node","installation","tracer","tracing","logging","cardano-node","cardano node"]},sidebar:"tutorialSidebar",previous:{title:"Peer to peer",permalink:"/documentation/cardano-node/p2p"},next:{title:"Trace messages",permalink:"/documentation/cardano-node/new-tracing-system/trace-messages"}},o={},l=[{value:"efficient, simple and flexible program tracing",id:"efficient-simple-and-flexible-program-tracing",level:3},{value:"Rationale",id:"rationale",level:2},{value:"Transition Period",id:"transition-period",level:2},{value:"Key Recommendations for Developers",id:"key-recommendations-for-developers",level:2},{value:"Tracer Construction Basics",id:"tracer-construction-basics",level:2},{value:"Namespace Concept Explanation",id:"namespace-concept-explanation",level:2},{value:"Typeclasses Overview",id:"typeclasses-overview",level:2},{value:"LogFormatting Typeclass",id:"logformatting-typeclass",level:3},{value:"MetaTrace Typeclass",id:"metatrace-typeclass",level:3},{value:"Metrics Integration",id:"metrics-integration",level:2},{value:"Frequency Limiting in Trace Filtering",id:"frequency-limiting-in-trace-filtering",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Integrating a New Tracer into cardano-node",id:"integrating-a-new-tracer-into-cardano-node",level:2},{value:"Message Filtering based on Severity",id:"message-filtering-based-on-severity",level:2},{value:"Comprehensive Trace Filtering",id:"comprehensive-trace-filtering",level:2},{value:"Privacy Annotations",id:"privacy-annotations",level:2},{value:"Detail Level in Trace Presentation",id:"detail-level-in-trace-presentation",level:2},{value:"Fold-Based Aggregation",id:"fold-based-aggregation",level:2},{value:"Dispatcher Routing Mechanism",id:"dispatcher-routing-mechanism",level:2},{value:"Documentation Generation",id:"documentation-generation",level:2},{value:"Consistency Checking",id:"consistency-checking",level:2},{value:"Trace Backends Overview",id:"trace-backends-overview",level:2},{value:"Data Points Overview and Deprecation Notice",id:"data-points-overview-and-deprecation-notice",level:2},{value:"References",id:"references",level:2},{value:"Future work",id:"future-work",level:2},{value:"Versioning",id:"versioning",level:3},{value:"Trace Consumers",id:"trace-consumers",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"trace-dispatcher",children:"trace-dispatcher"}),"\n",(0,i.jsx)(n.h3,{id:"efficient-simple-and-flexible-program-tracing",children:"efficient, simple and flexible program tracing"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"trace-dispatcher"})," is a library that enables definition of ",(0,i.jsx)(n.strong,{children:"tracing systems"})," -- systems that collect and manages traces -- as evidence of program execution."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#trace-dispatcher-efficient-simple-and-flexible-program-tracing",children:"trace-dispatcher: efficient, simple and flexible program tracing"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#rationale",children:"Rationale"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#transition-period",children:"Transition Period"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#key-recommendations-for-developers",children:"Key Recommendations for Developers"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#basic-tracer-topics",children:"Basic Tracer Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#tracer-construction-basics",children:"Tracer Construction Basics"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#namespace-concept-explanation",children:"Namespace Concept Explanation"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#typeclasses-overview",children:"Typeclasses Overview"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#logformatting-typeclass",children:"LogFormatting Typeclass"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#metatrace-typeclass",children:"MetaTrace Typeclass"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#metrics-integration",children:"Metrics Integration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#frequency-limiting-in-trace-filtering",children:"Frequency Limiting in Trace Filtering"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#configuration",children:"Configuration"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#advanced-tracer-topics",children:"Advanced Tracer Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#integrating-a-new-tracer-into-cardano-node",children:"Integrating a New Tracer into cardano-node"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#message-filtering-based-on-severity",children:"Message Filtering based on Severity"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#comprehensive-trace-filtering",children:"Comprehensive Trace Filtering"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#privacy-annotations",children:"Privacy Annotations"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#detail-level-in-trace-presentation",children:"Detail Level in Trace Presentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#fold-based-aggregation",children:"Fold-Based Aggregation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#dispatcher-routing-mechanism",children:"Dispatcher Routing Mechanism"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#documentation-generation",children:"Documentation Generation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#consistency-checking",children:"Consistency Checking"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#trace-backends-overview",children:"Trace Backends Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#data-points-overview-and-deprecation-notice",children:"Data Points Overview and Deprecation Notice"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#appendix",children:"Appendix"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#references",children:"References"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#future-work",children:"Future work"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#versioning",children:"Versioning"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#trace-consumers",children:"Trace Consumers"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"trace-dispatcher"})," library serves as a sophisticated solution for streamlined and effective tracing systems. Built upon the arrow-based ",(0,i.jsx)(n.code,{children:"contra-tracer"})," framework, it surpasses the capabilities of the ",(0,i.jsx)(n.code,{children:"iohk-monitoring"})," framework with the following enhancements:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Persistent activation of all tracers, adhering to the configured severity levels."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Granular configuration (such as filtering, limiting) of individual tracers based on hierarchical namespaces, extending down to individual messages."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Seamless transmission of traces to a dedicated ",(0,i.jsx)(n.code,{children:"cardano-tracer"})," process capable of handling traces from multiple nodes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Dynamic reconfiguration (i.e. hot-reloading) of tracing settings within a running node (after removal of legacy tracing)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Automatic generation of comprehensive documentation encompassing all trace messages, metrics, and datapoints."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Sanity and consistency checking of tracer implementations and tracing settings based on the system's introspective capability."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"transition-period",children:"Transition Period"}),"\n",(0,i.jsxs)(n.p,{children:["During the transitional phase, both legacy tracing, based on the ",(0,i.jsx)(n.code,{children:"iohk-monitoring"})," framework, and new tracing, leveraging ",(0,i.jsx)(n.code,{children:"trace-dispatcher"})," and ",(0,i.jsx)(n.code,{children:"cardano-tracer"}),", will coexist."]}),"\n",(0,i.jsx)(n.p,{children:"This interim period provides an opportunity to thoroughly test and enhance the new tracing system. Given the extensive repertoire of over 600 trace messages, the possibility of uncovering regressions and bugs is anticipated. Your assistance in identifying and rectifying these issues is invaluable."}),"\n",(0,i.jsx)(n.p,{children:"Please be aware that, owing to compatibility with the legacy system, the new tracing functionality will be slightly constrained during this transitional phase. Certain features, such as dynamic reconfiguration of a running node, will be temporarily unavailable. Additionally, there may be redundant implementations that are currently necessary but slated for refinement."}),"\n",(0,i.jsxs)(n.p,{children:["To activate new tracing, set the ",(0,i.jsx)(n.code,{children:"UseTraceDispatcher"})," in the node's config file value to ",(0,i.jsx)(n.code,{children:"true"}),". When making this switch, ensure that the configuration file includes the requisite values for the new tracing setup, as detailed in the subsequent section."]}),"\n",(0,i.jsx)(n.h2,{id:"key-recommendations-for-developers",children:"Key Recommendations for Developers"}),"\n",(0,i.jsx)(n.p,{children:"Kindly consider the following important suggestions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The current tracing system employs two methods for message identification: a hierarchical name known as its Namespace and the Kind field in machine representation. Our implementation is rooted in the namespace, and we are actively moving towards deprecating the Kind field for a singular reliance on namespaces. Therefore, we strongly recommend utilizing namespaces for any trace analysis tools, as the ",(0,i.jsx)(n.em,{children:"Kind field will be phased out in the near future"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Avoid using strictness annotations for trace types. Given that trace messages are either promptly discarded or instantly converted to another format without storage, strictness annotations introduce unnecessary inefficiencies without tangible benefits."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When developing new tracers, consider creating the new tracers first and subsequently mapping to old tracers. You can refer to numerous examples in ",(0,i.jsx)(n.code,{children:"cardano-node"})," under ",(0,i.jsx)(n.code,{children:"Cardano.Node.Tracing.Tracers"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"For inquiries and reviews, please reach out to the Performance & Tracing team. Your collaboration and questions are welcome to ensure a seamless transition and optimal utilization of the new tracing framework."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"basic-tracer-topics",children:"Basic Tracer Topics"}),"\n",(0,i.jsx)(n.h2,{id:"tracer-construction-basics",children:"Tracer Construction Basics"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Define an Algebraic Data Type (ADT) and assign distinct constructors to each trace message."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"An example is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data TraceAddBlockEvent blk =\n    IgnoreBlockOlderThanK (RealPoint blk)\n  | IgnoreBlockAlreadyInVolatileDB (RealPoint blk)\n  ...\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Create a tracer for this data type using the provided Haskell function:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- | Generate a tracer conforming to the cardano node requirements.\n-- The tracer must be an instance of LogFormatting for message display\n-- and an instance of MetaTrace for meta-information such as\n-- severity, privacy, details, and backends.\n-- The tracer receives those backends as arguments:\n--   * 'trStdout':  stdout tracing\n--   * 'trForward': trace forwarding\n--   * 'mbTrEkg':   (optional) EKG monitoring\n-- The tracer is supplied with a 'name' as an array of text, which is prepended to its namespace.\n-- This function returns the new tracer.\n\nmkCardanoTracer :: forall evt.\n    ( LogFormatting evt\n    , MetaTrace evt )\n  => Trace IO FormattedMessage\n  -> Trace IO FormattedMessage\n  -> Maybe (Trace IO FormattedMessage)\n  -> [Text]\n  -> IO (Trace IO evt)\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is imperative that the tracer backends (the first three parameters) remain consistent across all tracers. For example, only one stdout backend is permitted for use in any program."}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Configure the returned tracer with:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- | Invoke this function during initialization (and potentially later for reconfiguration).\n-- ConfigReflection is utilized to gather information about the tracers\n-- and is employed to optimize the tracers.\n-- TraceConfig represents the configuration, typically loaded from a configuration file.\n-- While it is feasible to provide more than one tracer of the same type,\n-- this scenario is not common.\n-- This function does not return a value.\n\nconfigureTracers :: forall a m.\n    ( MetaTrace a\n    , MonadIO m )\n  => ConfigReflection\n  -> TraceConfig\n  -> [Trace m a]\n  -> m ()\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsx)(n.li,{children:"Trace Emission Process"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["To emit a trace, employing a message and its corresponding tracer, utilize the ",(0,i.jsx)(n.code,{children:"traceWith"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:'traceWith :: Trace m a -> a -> m ()\n-- For example:\naddBlockTracer <- mkCardanoTracer trStdout trForward (Just trEkg) ["ChainDB"]\nconfigureTracers configReflect config [addBlockTracer]\n..\ntraceWith addBlockTracer (IgnoreBlockOlderThanK p)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"namespace-concept-explanation",children:"Namespace Concept Explanation"}),"\n",(0,i.jsxs)(n.p,{children:["Understanding the concept of namespaces is crucial for comprehending the tracing system and the ",(0,i.jsx)(n.code,{children:"MetaTrace"})," typeclass. Tracers are systematically organized within a hierarchical tracer namespace, with tree nodes and leaves identified by ",(0,i.jsx)(n.code,{children:"Text"})," name components."]}),"\n",(0,i.jsxs)(n.p,{children:["The trace dispatcher requires careful organization to ensure that all messages possess a unique name within this namespace. Moreover, the same tracer type can be utilized in different contexts, such as for local and remote messages. To enable this flexibility, the 'inner' namespace is prefixed by the namespace passed to a tracer during construction (refer to ",(0,i.jsx)(n.code,{children:"mkCardanoTracer"})," example above)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:'-- A unique identifier for every message, composed of arrays of text\n-- A namespace can also appear with the tracer name (e.g., "ChainDB.OpenEvent.OpenedDB"),\n-- or more prefixes; currently, a NamespaceOuter is used.\n-- The inner namespace may not be empty.\ndata Namespace a = Namespace {\n    nsPrefix :: [Text]\n  , nsInner  :: [Text]}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Every namespace is composed of:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"system namespace (empty for cardano, but was cardano in old tracing)"}),"\n",(0,i.jsx)(n.li,{children:"tracer namespace (argument of mkCardanoTracer)"}),"\n",(0,i.jsx)(n.li,{children:"inner namespace (provided by the MetaTrace typeclass)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The tracer namespace serves pivotal roles in:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": It defines the overall structure of the generated documentation output."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Configuration"}),": It allows reference to tracers that need reconfiguration, such as altering their severity."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": The messages carry the tracer namespace, providing clarity and context in the output."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"typeclasses-overview",children:"Typeclasses Overview"}),"\n",(0,i.jsx)(n.p,{children:"For the effective integration of trace messages into the tracing system, two essential typeclasses must be implemented: one for message formatting and another for meta-information."}),"\n",(0,i.jsx)(n.h3,{id:"logformatting-typeclass",children:"LogFormatting Typeclass"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"LogFormatting"})," typeclass governs the presentation of trace messages, encompassing the mapping of traces to metrics and messages. It includes the following methods:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"forMachine"})," method caters to a machine-readable representation, adaptable based on the detail level. Implementation is mandatory for the trace author."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"forHuman"})," method renders the message in a human-readable form. Its default implementation is an\nempty text, which will be replaced by forMachine in the rendering, if forHuman is empty. The forMachine\nwill by default rendered with a DNormal detsil level, if no other information is provided."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"asMetrics"})," method portrays the message as 0 to n metrics. The default implementation assumes no metrics. Each metric can optionally specify a hierarchical identifier as a ",(0,i.jsx)(n.code,{children:"[Text]"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:'class LogFormatting a where\n  -- Machine readable representation with varying details based on the detail level.\n  forMachine :: DetailLevel -> a -> Aeson.Object\n\n  -- Human readable representation.\n  forHuman :: a -> Text\n  forHuman _v = ""\n\n  -- Metrics representation.\n  asMetrics :: a -> [Metric]\n  asMetrics _v = []\n'})}),"\n",(0,i.jsx)(n.p,{children:"Metrics, represented as numbers, serve to monitor the running system and can be accessed, for example, through Prometheus."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data Metric\n  -- Integer metric with a named identifier.\n    = IntM Text Integer\n  -- Double metric with a named identifier.\n    | DoubleM Text Double\n  -- Counter metric with a named identifier and an optional limit.\n    | CounterM Text (Maybe Int)\n  deriving (Show, Eq)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"metatrace-typeclass",children:"MetaTrace Typeclass"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"MetaTrace"})," typeclass plays a pivotal role in providing meta-information for trace messages. It includes the following methods:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"namespaceFor"}),": Offers a distinct (inner) namespace for each trace message."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"severityFor"}),": Provides severity for a given namespace. As some severities depend not only on the message type but also on the individual message, the actual message may be passed as well."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"privacyFor"}),": Determines whether a message is ",(0,i.jsx)(n.code,{children:"Private"})," or ",(0,i.jsx)(n.code,{children:"Public"}),". Private messages are not sent to ",(0,i.jsx)(n.code,{children:"cardano-tracer"})," and are only displayed on the stdout trace. If no implementation is given, ",(0,i.jsx)(n.code,{children:"Public"})," is chosen."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"detailsFor"}),": Specifies the level of details for printing messages. Options include ",(0,i.jsx)(n.code,{children:"DMinimal"}),", ",(0,i.jsx)(n.code,{children:"DNormal"}),", ",(0,i.jsx)(n.code,{children:"DDetailed"}),", and ",(0,i.jsx)(n.code,{children:"DMaximum"}),". If no implementation is given, ",(0,i.jsx)(n.code,{children:"DNormal"})," is chosen."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"documentFor"}),": Allows the addition of optional documentation for messages as text. See section ",(0,i.jsx)(n.a,{href:"#documentation-generation",children:"Documentation Generation"})," later in this document."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"metricsDocFor"}),": Enables the addition of documentation for metrics carried by the respective message. If no implementation is given, the default is no metrics."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"allNamespaces"}),": Must return an array with all namespaces of this trace type."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"class MetaTrace a where\n  namespaceFor  :: a -> Namespace a\n\n  severityFor   :: Namespace a -> Maybe a -> Maybe SeverityS\n\n  privacyFor    :: Namespace a -> Maybe a -> Maybe Privacy\n  privacyFor _ _ =  Just Public\n\n  detailsFor    :: Namespace a -> Maybe a -> Maybe DetailLevel\n  detailsFor _ _ =  Just DNormal\n\n  documentFor   :: Namespace a -> Maybe Text\n\n  metricsDocFor :: Namespace a -> [(Text, Text)]\n  metricsDocFor _ = []\n\n  allNamespaces :: [Namespace a]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"metrics-integration",children:"Metrics Integration"}),"\n",(0,i.jsxs)(n.p,{children:["Metrics are seamlessly incorporated into the system through regular trace messages implementing the ",(0,i.jsx)(n.code,{children:"asMetrics"})," function within the ",(0,i.jsx)(n.code,{children:"LogFormatting"})," typeclass. Unlike other trace components, metrics are not subjected to filtering and are consistently provided. This occurs as long as the ",(0,i.jsx)(n.code,{children:"EKGBackend"})," is configured for the message. The ",(0,i.jsx)(n.code,{children:"EKGBackend"})," then forwards these metrics to ",(0,i.jsx)(n.code,{children:"cardano-tracer"})," for additional processing. Subsequently, they are dispatched as Prometheus metrics, extending their utility and visibility."]}),"\n",(0,i.jsx)(n.h2,{id:"frequency-limiting-in-trace-filtering",children:"Frequency Limiting in Trace Filtering"}),"\n",(0,i.jsx)(n.p,{children:"Frequency filtering is an integral aspect of trace filtering, offering an optional mechanism to limit the observable frequency of individual trace messages."}),"\n",(0,i.jsx)(n.p,{children:"In essence, this involves a fair and probabilistic suppression of messages within a particular trace when their moving-average frequency surpasses a specified threshold parameter."}),"\n",(0,i.jsx)(n.p,{children:"The frequency limiter, in addition to controlling message frequency, emits a suppression summary message under specific conditions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When message suppression commences."}),"\n",(0,i.jsx)(n.li,{children:"Every 10 seconds during active limiting, providing the count of suppressed messages."}),"\n",(0,i.jsx)(n.li,{children:"When message suppression concludes, indicating the total number of suppressed messages."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Usually frequency limiters can be just added by configuration, for special cases you\ncan construct them in your code. Each frequency limiter is assigned a name for identification purposes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"limitFrequency\n  :: forall a m . MonadUnliftIO m\n  => Double   -- messages per second\n  -> Text     -- name of this limiter\n  -> Trace m TraceDispatcherMessage -- the limiter's messages\n  -> Trace m a -- the trace subject to limitation\n  -> m (Trace m a) -- the original trace\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is important to note that frequency filtering is designed to be applied selectively to a subset of traces, specifically those identified as potentially noisy. The configuration of frequency limits can thus be tailored to this subset of traces."}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.p,{children:"The configurability of dispatchers provided by this library relies on:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tracer Namespace-based Configurability"}),": Configurable down to single message granularity based on tracer namespaces."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Runtime Reconfigurability"}),": Triggered by invoking ",(0,i.jsx)(n.code,{children:"configureTracers"}),", enabling changes during program execution."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The usual form to provide a configuration is via a configuration file, wich can be in JSON or YAML format. The options that\ncan be given based on a namespace are: ",(0,i.jsx)(n.code,{children:"severity"}),", ",(0,i.jsx)(n.code,{children:"detail"}),", ",(0,i.jsx)(n.code,{children:"backends"})," and ",(0,i.jsx)(n.code,{children:"limiter"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Backends can be a combination of ",(0,i.jsx)(n.code,{children:"Forwarder"}),", ",(0,i.jsx)(n.code,{children:"EKGBackend"}),", and\none of ",(0,i.jsx)(n.code,{children:"Stdout MachineFormat"}),", ",(0,i.jsx)(n.code,{children:"tdout HumanFormatColoured"})," and ",(0,i.jsx)(n.code,{children:"Stdout HumanFormatUncoloured"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Use new tracing\nUseTraceDispatcher: True\n\nTraceOptions:\n  "": # Options for all tracers, if not overwritten:\n    severity: Notice\n    detail: DNormal\n    backends:\n      - Stdout MachineFormat\n      - EKGBackend\n      - Forwarder\n\n  ChainDB: # Show as well messages with severity Info for all ChainDB traces.\n    severity: Info\n    detail: DDetailed\n\n  ChainDB.AddBlockEvent.AddedBlockToQueue: # Limit the AddedBlockToQueue events to a maximum of two per second.\n    maxFrequency: 2.0\n\nTraceOptionForwarder: # Configure the forwarder\n    address:\n      filePath: /tmp/forwarder.sock\n    mode: Initiator\n\n# Frequency of Peer messages set to two seconds\nTraceOptionPeerFrequency: 2000\n'})}),"\n",(0,i.jsx)(n.p,{children:"The same in JSON looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "UseTraceDispatcher": true,\n  "TraceOptions": {\n    "": {\n      "severity": "Notice",\n      "detail": "DNormal",\n      "backends": [\n        "Stdout MachineFormat",\n        "EKGBackend",\n        "Forwarder"\n      ]\n    },\n    "ChainDB": {\n      "severity": "Info",\n      "detail": "DDetailed"\n    },\n    "ChainDB.AddBlockEvent.AddedBlockToQueue": {\n      "maxFrequency": 2.0\n    }\n  },\n  "TraceOptionForwarder": {\n    "address": {\n      "filePath": "/tmp/forwarder.sock"\n    },\n    "mode": "Initiator"\n  },\n  "TraceOptionPeerFrequency": 2000\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"For explanations of the trace forwarder option refer to the following document:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/input-output-hk/cardano-node-wiki/wiki/New-Tracing-Quickstart",children:"New Tracing Quickstart"})}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"TraceOptions"})," is empty, or other entries are missing in the configuration file, default entries are taken from\n",(0,i.jsx)(n.a,{href:"https://github.com/intersectmbo/cardano-node/blob/master/cardano-node/src/Cardano/Node/Tracing/DefaultTraceConfig.hs",children:"Cardano.Node.Tracing.DefaultTraceConfig"})," module."]}),"\n",(0,i.jsx)(n.h1,{id:"advanced-tracer-topics",children:"Advanced Tracer Topics"}),"\n",(0,i.jsx)(n.p,{children:"The functionality of the new tracing system is composable using basic combinators defined on contravariant tracing.\nIn this part of the document we introduce the underlying functions. You should look here if you want to\nimplement some advanced functionality."}),"\n",(0,i.jsx)(n.h2,{id:"integrating-a-new-tracer-into-cardano-node",children:"Integrating a New Tracer into cardano-node"}),"\n",(0,i.jsx)(n.p,{children:"Presently, the process of adding a new tracer involves making changes in three specific modules. However, we anticipate that this requirement will be simplified once the old tracing system is phased out. The current modules where modifications are needed to add a new tracer are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cardano.Node.Tracing.Tracers"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cardano.Node.Tracing.Documentation"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cardano.Node.Tracing.Consistency"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"message-filtering-based-on-severity",children:"Message Filtering based on Severity"}),"\n",(0,i.jsxs)(n.p,{children:["The concept of severity in the new system is articulated through an enumeration outlined in ",(0,i.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc5424#section-6.2.1",children:"section 6.2.1 of RFC 5424"}),". The severity levels, ranging from the least severe (",(0,i.jsx)(n.code,{children:"Debug"}),") to the most severe (",(0,i.jsx)(n.code,{children:"Emergency"}),"), provide a framework for ignoring messages with severity levels below a globally configured severity cutoff."]}),"\n",(0,i.jsxs)(n.p,{children:["To enhance severity filtering, we introduce the option of ",(0,i.jsx)(n.code,{children:"Silence"}),". This addition allows for the unconditional silencing of a specific trace, essentially representing the deactivation of tracers \u2014 a semantic continuation of the functionality in the legacy system."]}),"\n",(0,i.jsx)(n.p,{children:"The following trace combinators play a role in modifying the annotated severity of a trace:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- Sets severities for the messages in this trace based on the MetaTrace class\nwithSeverity :: forall m a. (Monad m, MetaTrace a) => Trace m a -> Trace m a\n\n-- Sets severity for the messages in this trace\nsetSeverity :: Monad m => SeverityS -> Trace m a -> Trace m a\n\n-- Filters out messages with a severity less than the given one\nfilterTraceBySeverity :: Monad m\n  => Maybe SeverityF\n  -> Trace m a\n  -> Trace m a\n"})}),"\n",(0,i.jsx)(n.p,{children:"When these combinators are applied multiple times to a single trace, only the outermost application has an effect, rendering subsequent applications inconsequential."}),"\n",(0,i.jsxs)(n.p,{children:["In the absence of trace context or configured severity overrides, ",(0,i.jsx)(n.code,{children:"Info"})," serves as the default severity."]}),"\n",(0,i.jsx)(n.h2,{id:"comprehensive-trace-filtering",children:"Comprehensive Trace Filtering"}),"\n",(0,i.jsxs)(n.p,{children:["A versatile filtering mechanism is provided, granting access to both the object and a ",(0,i.jsx)(n.code,{children:"LoggingContext"}),", encompassing the namespace along with optional severity, privacy, and detail level:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- Don't process further if the result of the selector function\n-- is False.\nfilterTrace :: (Monad m)\n  => ((LoggingContext, a) -> Bool)\n  -> Trace m a\n  -> Trace m a\n\n-- Context carried by any log message\ndata LoggingContext = LoggingContext {\n    lcNSInner   :: [Text]\n  , lcNSPrefix  :: [Text]\n  , lcSeverity  :: Maybe SeverityS\n  , lcPrivacy   :: Maybe Privacy\n  , lcDetails   :: Maybe DetailLevel\n  }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For instance, you can create a filter function to display only ",(0,i.jsx)(n.em,{children:"Public"})," messages:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"filterTrace (\\(c, _) -> case lcPrivacy c of\n                Just s  -> s == Public\n                Nothing -> False) -- privacy unknown, don't send out\n"})}),"\n",(0,i.jsx)(n.p,{children:"This capability allows for flexible and fine-grained control over the inclusion or exclusion of messages based on a variety of contextual criteria."}),"\n",(0,i.jsx)(n.h2,{id:"privacy-annotations",children:"Privacy Annotations"}),"\n",(0,i.jsx)(n.p,{children:"In our tracing system, privacy annotations empower the distinction of messages that remain within the system and are not sent over the network, but are solely displayed on stdout. This privacy feature is defined through the following enumeration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data Privacy\n    = Confidential | Public\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When a trace carries a ",(0,i.jsx)(n.strong,{children:"Confidential"})," privacy level, it implies that the trace remains internalized within the system, with the exception of being displayed via standard output."]}),"\n",(0,i.jsx)(n.p,{children:"The annotation mechanism for privacy mirrors that of severity:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- Sets privacy for the messages in this trace based on the MetaTrace class\nwithPrivacy :: forall m a. (Monad m, MetaTrace a) => Trace m a -> Trace m a\n\n-- Sets privacy Confidential for the messages in this trace\nprivately :: Monad m => Trace m a -> Trace m a\n\n-- Only processes messages further with a privacy greater than the given one\nfilterTraceByPrivacy :: (Monad m) =>\n     Maybe Privacy\n  -> Trace m a\n  -> Trace m a\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the absence of privacy annotations, ",(0,i.jsx)(n.code,{children:"Public"})," serves as the default privacy level."]}),"\n",(0,i.jsx)(n.p,{children:"Trace privacy, unlike severity, is not configurable."}),"\n",(0,i.jsx)(n.p,{children:"Trace filtering responds to privacy context as follows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Traces marked as ",(0,i.jsx)(n.code,{children:"Confidential"})," can solely reach the ",(0,i.jsx)(n.code,{children:"stdout"})," trace-out."]}),"\n",(0,i.jsxs)(n.li,{children:["Traces marked as ",(0,i.jsx)(n.code,{children:"Public"})," reach both the ",(0,i.jsx)(n.code,{children:"stdout"})," and ",(0,i.jsx)(n.code,{children:"trace-forwarder"})," trace-outs."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Effectively, preventing leaks of ",(0,i.jsx)(n.code,{children:"Confidential"})," traces due to logging misconfiguration is inherent \u2014 any potential leak can only occur if the user explicitly permits network access to the standard output of the traced program."]}),"\n",(0,i.jsx)(n.h2,{id:"detail-level-in-trace-presentation",children:"Detail Level in Trace Presentation"}),"\n",(0,i.jsx)(n.p,{children:"A crucial facet of trace presentation is the degree of detail provided for each trace. This consideration holds significance because the generated program traces may inherently include exhaustive details. Presenting every intricate detail in its entirety could impose a considerable burden on trace handling."}),"\n",(0,i.jsx)(n.p,{children:"To address this, a configurable mechanism for controlling the level of detail is introduced, allowing customization down to specific messages."}),"\n",(0,i.jsx)(n.p,{children:"The control over detail levels is manifested through the following enumeration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data DetailLevel = DMinimal | DNormal | DDetailed | DMaximum\n"})}),"\n",(0,i.jsx)(n.p,{children:"This detail level control ensures that the presentation of traces strikes a balance between informativeness and efficiency, catering to diverse needs and preferences."}),"\n",(0,i.jsx)(n.h2,{id:"fold-based-aggregation",children:"Fold-Based Aggregation"}),"\n",(0,i.jsx)(n.p,{children:"When there is a need for aggregating information from multiple consecutive messages, the following fold functions can be employed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- Folds the monadic cata function with acc over a.\n-- Uses an MVar to store the state\nfoldTraceM :: forall a acc m . (MonadUnliftIO m)\n  => (acc -> LoggingContext -> a -> m acc)\n  -> acc\n  -> Trace m (Folding a acc)\n  -> m (Trace m a)\n\n-- Like foldTraceM, but filters the trace by a predicate.\nfoldCondTraceM :: forall a acc m . (MonadUnliftIO m)\n  => (acc -> LoggingContext -> a -> m acc)\n  -> acc\n  -> (a -> Bool)\n  -> Trace m (Folding a acc)\n  -> m (Trace m a)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To facilitate typechecking, the ",(0,i.jsx)(n.code,{children:"Folding"})," type is utilized, and it can be removed by the ",(0,i.jsx)(n.code,{children:"unfold"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"newtype Folding a acc = Folding acc\n\nunfold :: Folding a b -> b\nunfold (Folding b) = b\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Given that tracers can be invoked from different threads, an ",(0,i.jsx)(n.code,{children:"MVar"})," is internally employed to ensure correct behavior."]}),"\n",(0,i.jsxs)(n.p,{children:["As an illustrative example, let's consider a scenario where we want to log a measurement value along with the sum of all measurements recorded thus far. We define a ",(0,i.jsx)(n.code,{children:"Stats"})," type to store the sum alongside the measurement, and a ",(0,i.jsx)(n.code,{children:"fold"}),"-compatible function to calculate new ",(0,i.jsx)(n.code,{children:"Stats"})," from old ",(0,i.jsx)(n.code,{children:"Stats"})," and ",(0,i.jsx)(n.code,{children:"Measure"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data Stats = Stats {\n    sMeasure :: Double,\n    sSum     :: Double\n    }\n\ncalculateS :: MonadIO m => Stats -> LoggingContext -> Double -> m Stats\ncalculateS Stats{..} _ val = pure $ Stats val (sSum + val)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["With these components in place, we can define the aggregation tracer using the ",(0,i.jsx)(n.code,{children:"foldTraceM"})," procedure. Subsequently, when we log measurement values, the tracer outputs the corresponding ",(0,i.jsx)(n.code,{children:"Stats"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"aggregationTracer <- foldTraceM calculateS (Stats 0.0 0.0) exampleTracer\ntraceWith 1.1 aggregationTracer -- measure: 1.1 sum: 1.1\ntraceWith 2.0 aggregationTracer -- measure: 2.0 sum: 3.1\n"})}),"\n",(0,i.jsx)(n.p,{children:"This demonstrates how fold-based aggregation facilitates the accumulation of information over consecutive messages, enabling insightful data summaries."}),"\n",(0,i.jsx)(n.h2,{id:"dispatcher-routing-mechanism",children:"Dispatcher Routing Mechanism"}),"\n",(0,i.jsx)(n.p,{children:"In the process of defining the trace dispatcher, it can be advantageous to employ a set of functions for routing messages. When there's a need to dispatch a trace message to different tracers based on specific criteria, the following function proves valuable:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- Allows routing to different tracers, based on the message being processed.\n-- The second argument must mappend all possible tracers of the first\n-- argument to one tracer. This is required for the configuration!\nroutingTrace :: forall m a. Monad m\n  => (a -> m (Trace m a))\n  -> Trace m a\n  -> Trace m a\n\nlet resTrace = routingTrace routingFunction (tracer1 <> tracer2)\n  where\n    routingFunction LO1 {} = tracer1\n    routingFunction LO2 {} = tracer2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this context, the second argument must encapsulate the combination (using ",(0,i.jsx)(n.code,{children:"mappend"}),") of all tracers utilized in the routing trace function into a single tracer. This amalgamation is crucial for the subsequent configuration steps."]}),"\n",(0,i.jsx)(n.p,{children:"While a more secure interface could be constructed using a map of values to tracers, the choice here prioritizes the ability for comprehensive pattern matching. The flexibility offered by full pattern matching outweighs the potential disadvantages, given the context."}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, to route a single trace to multiple tracers simultaneously, the fact that ",(0,i.jsx)(n.code,{children:"Tracer"})," is a ",(0,i.jsx)(n.code,{children:"Semigroup"})," allows us to utilize the ",(0,i.jsx)(n.code,{children:"<>"})," operator or ",(0,i.jsx)(n.code,{children:"mconcat"})," for lists of tracers:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"(<>) :: Monoid m => m -> m -> m\nmconcat :: Monoid m => [m] -> m\n"})}),"\n",(0,i.jsx)(n.p,{children:"For instance, to direct messages from one trace to two tracers simultaneously, we can use:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"let resTrace = tracer1 <> tracer2\n"})}),"\n",(0,i.jsx)(n.h2,{id:"documentation-generation",children:"Documentation Generation"}),"\n",(0,i.jsxs)(n.p,{children:["The documentation for tracers is periodically generated and can be accessed in the cardano-node-wiki repository at the following path: ",(0,i.jsx)(n.a,{href:"https://github.com/input-output-hk/cardano-node-wiki/blob/main/docs/new-tracing/tracers_doc_generated.md",children:"cardano-node-wiki/tracers_doc_generated.md"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To generate the documentation within GHCi, load the ",(0,i.jsx)(n.code,{children:"Cardano.Node.Tracing.Documentation"})," module and execute the ",(0,i.jsx)(n.code,{children:"runTraceDocumentationCmd"})," function with the appropriate parameters:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data TraceDocumentationCmd\n  = TraceDocumentationCmd\n    { tdcConfigFile :: FilePath -- file path to a node config file\n    , tdcOutput     :: FilePath -- file path to output the documentation\n    }\n\nrunTraceDocumentationCmd\n  :: TraceDocumentationCmd\n  -> IO ()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The self-documentation capabilities of ",(0,i.jsx)(n.code,{children:"trace-dispatcher"})," rely on documentation annotations provided by the ",(0,i.jsx)(n.code,{children:"documentFor"})," and ",(0,i.jsx)(n.code,{children:"metricsDocFor"})," methods within the ",(0,i.jsx)(n.code,{children:"MetaTrace"})," typeclass. Additionally, a specialized dispatcher execution mode emits documentation for all annotated traces, utilizing the tracer namespace to structure the document."]}),"\n",(0,i.jsxs)(n.p,{children:["To generate the documentation, first, call ",(0,i.jsx)(n.code,{children:"documentTracer"})," for each message type with the associated tracers, then use ",(0,i.jsx)(n.code,{children:"docuResultsToText"})," with the accumulated lists."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:'-- This function calls document tracers and returns a DocTracer result\ndocumentTracer :: forall a.\n     MetaTrace a\n  => Trace IO a\n  -> IO DocTracer\n\n-- Finally, generate text from all the builders\ndocuResultsToText :: DocTracer -> TraceConfig -> IO Text\n\n-- For example\n  b1 <- documentTracer traceForgeEventDocu [t1, t2]\n  b2 <- documentTracer .. ..\n  ..\n  bn <- documentTracer .. ..\n  writeFile "Docu.md" (docuResultsToText (b1 ++ b2 ++ ... ++ bn))\n'})}),"\n",(0,i.jsx)(n.p,{children:"A generated documentation snippet for a simple message may appear as follows:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Forge.Loop.StartLeadershipCheck"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Start of the leadership check."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Severity:  ",(0,i.jsx)(n.code,{children:"Info"}),"\nPrivacy:   ",(0,i.jsx)(n.code,{children:"Public"}),"\nDetails:   ",(0,i.jsx)(n.code,{children:"DNormal"})]}),"\n",(0,i.jsx)(n.p,{children:"From the current configuration:"}),"\n",(0,i.jsxs)(n.p,{children:["Backends:\n",(0,i.jsx)(n.code,{children:"EKGBackend"}),",\n",(0,i.jsx)(n.code,{children:"Stdout MachineFormat"}),",\n",(0,i.jsx)(n.code,{children:"Forwarder"}),"\nFiltered ",(0,i.jsx)(n.code,{children:"Visible"})," by config value: ",(0,i.jsx)(n.code,{children:"Info"})]}),"\n",(0,i.jsx)(n.h2,{id:"consistency-checking",children:"Consistency Checking"}),"\n",(0,i.jsxs)(n.p,{children:["As namespaces are essentially strings, the type system doesn't inherently ensure the consistency of namespaces. To address this concern, we have incorporated consistency check functionality into ",(0,i.jsx)(n.code,{children:"trace-dispatcher"}),". Within the node, you can invoke the following procedure from the ",(0,i.jsx)(n.code,{children:"Cardano.Node.Tracing.Consistency"})," module. It returns an array of ",(0,i.jsx)(n.code,{children:"Text"}),", an empty list indicating that everything is in order."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- | Check the configuration in the given file.\n-- Check the general structure of namespaces.\n-- An empty return list means everything is well.\ncheckNodeTraceConfiguration ::\n     FilePath -- path to a node configuration file\n  -> IO [Text]\n"})}),"\n",(0,i.jsx)(n.p,{children:'An example text is "Config namespace error: i.am.an.invalid.namepace" .'}),"\n",(0,i.jsxs)(n.p,{children:["This check is performed within a ",(0,i.jsx)(n.code,{children:"cardano-node"})," test case (",(0,i.jsx)(n.code,{children:"Test.Cardano.Tracing.NewTracing.Consistency.tests"}),"), ensuring that it is automatically verified with each pull request."]}),"\n",(0,i.jsx)(n.p,{children:"The consistency checks cover the following aspects:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Every namespace in ",(0,i.jsx)(n.code,{children:"all namespaces"})," must be unique."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Each namespace is a terminal and is not a part of another namespace."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Namespaces in the ",(0,i.jsx)(n.code,{children:"severityFor"}),", ",(0,i.jsx)(n.code,{children:"privacyFor"}),", ",(0,i.jsx)(n.code,{children:"detailsFor"}),", ",(0,i.jsx)(n.code,{children:"documentFor"}),", and ",(0,i.jsx)(n.code,{children:"metricsDocFor"})," functions are consistent with the ",(0,i.jsx)(n.code,{children:"allNamespaces"})," definition."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Any namespace in the configuration must be found by a hierarchical lookup in ",(0,i.jsx)(n.code,{children:"all namespaces"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"trace-backends-overview",children:"Trace Backends Overview"}),"\n",(0,i.jsx)(n.p,{children:"As mentioned earlier, trace backends serve as the final destinations for all traces once they have undergone trace interpretation, resulting in metrics and messages. The system defines three trace backends:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Standard Tracer:"})," This is the fundamental standard output tracer. Notably, it can accept both regular and confidential traces. It's important to construct only one standard tracer in any application, as attempting to create a new one will result in an exception."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"standardTracer :: forall m. (MonadIO m)\n  => m (Trace m FormattedMessage)\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Trace-Forward Tracer:"})," This is a network-only sink dedicated to forwarding messages using typed protocols over TCP or local sockets. It exclusively handles public traces and should be instantiated only once per application."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"forwardTracer :: forall m. (MonadIO m)\n  => ForwardSink TraceObject\n  -> Trace m FormattedMessage\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"EKG Tracer:"})," This tracer submits metrics to a local EKG store, which then further forwards the messages."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"ekgTracer :: MonadIO m\n  => Either Metrics.Store Server\n  -> m (Trace m FormattedMessage)\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"It's imperative to note that constructing more than one instance of each tracer in an application may lead to exceptions and should be avoided."}),"\n",(0,i.jsx)(n.h2,{id:"data-points-overview-and-deprecation-notice",children:"Data Points Overview and Deprecation Notice"}),"\n",(0,i.jsxs)(n.p,{children:["In the imminent future, ",(0,i.jsx)(n.code,{children:"DataPoint"}),"s will be deprecated and replaced by a subscription model."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"DataPoint"}),"s provide a means for processes outside of ",(0,i.jsx)(n.code,{children:"cardano-node"})," to inquire about the node's runtime state. Essentially similar to metrics, ",(0,i.jsx)(n.code,{children:"DataPoint"}),"s, however, have an Algebraic Data Type (ADT) structure, allowing them to represent structured information beyond simple metrics. This feature enables external processes to query and access specific details of a running cardano-node, such as the node's basic information."]}),"\n",(0,i.jsxs)(n.p,{children:["Implemented as special tracers, ",(0,i.jsx)(n.code,{children:"DataPoint"}),"s package objects into ",(0,i.jsx)(n.code,{children:"DataPoint"})," constructors and necessitate a ",(0,i.jsx)(n.code,{children:"ToJSON"})," instance for these objects. The set of ",(0,i.jsx)(n.code,{children:"DataPoint"}),"s provided by the node follows the same namespace structure as metrics and log messages. While ",(0,i.jsx)(n.code,{children:"DataPoint"}),"s operate independently of tracing, they are stored locally, facilitating on-demand queries for the latest values of a specific ",(0,i.jsx)(n.code,{children:"DataPoint"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["It is important to note that DataPoints will soon be deprecated, and a subscription model will take their place. Additionally, detailed information on accepting DataPoints from an external process can be found in ",(0,i.jsx)(n.a,{href:"https://github.com/input-output-hk/cardano-node-wiki/wiki/cardano-node-and-DataPoints:-demo",children:"this document"}),". The ",(0,i.jsx)(n.a,{href:"https://github.com/intersectmbo/cardano-node/blob/master/cardano-tracer/demo/acceptor.hs",children:(0,i.jsx)(n.code,{children:"demo-acceptor"})})," application is available for requesting specific DataPoints by name and displaying their values."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"-- A simple dataPointTracer supporting the construction of a namespace.\nmkDataPointTracer :: forall dp. (ToJSON dp, MetaTrace dp, NFData dp)\n  => Trace IO DataPoint\n  -> IO (Trace IO dp)\n"})}),"\n",(0,i.jsx)(n.h1,{id:"appendix",children:"Appendix"}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.p,{children:["The following document is periodically regenerated to provide comprehensive documentation for all trace messages, metrics, and data points within ",(0,i.jsx)(n.code,{children:"cardano-node"}),". It also outlines the handling of these messages based on the current default configuration:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/documentation/cardano-node/new-tracing-system/trace-messages",children:"Generated Cardano Trace Documentation"})}),"\n",(0,i.jsx)(n.p,{children:"For a quick start for administrators transitioning to new the new tracing system, refer to the following document:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/input-output-hk/cardano-node-wiki/wiki/New-Tracing-Quickstart",children:"New Tracing Quickstart"})}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, this document delves into ",(0,i.jsx)(n.code,{children:"cardano-tracer"}),", a separate application designed for logging and monitoring Cardano nodes:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/intersectmbo/cardano-node/blob/master/cardano-tracer/docs/cardano-tracer.md",children:"Cardano Tracer"})}),"\n",(0,i.jsx)(n.h2,{id:"future-work",children:"Future work"}),"\n",(0,i.jsx)(n.h3,{id:"versioning",children:"Versioning"}),"\n",(0,i.jsx)(n.p,{children:"Versioning for trace messages stands as a crucial component that significantly contributes to the functionality and maintainability of our system. We acknowledge the importance of associating version numbers with log messages, ensuring transparency and consistency throughout the application lifecycle."}),"\n",(0,i.jsx)(n.p,{children:"Adhering to a change protocol and establishing a clear correlation between node version numbers and trace version numbers is a prudent strategy. This approach aids in the effective management and communication of updates, alterations, and improvements to our tracing system. Such alignment guarantees that any modifications to the tracing system are accurately reflected and comprehended by both the development team and the broader Cardano community."}),"\n",(0,i.jsx)(n.p,{children:"Anticipating the forthcoming development phase, we are eager to design and implement this versioning feature. Our goal is to seamlessly integrate it into our overall system architecture, bolstering our capacity to adapt and evolve. This ensures a clear, consistent, and structured approach to trace messages, enhancing our system's resilience and comprehensibility."}),"\n",(0,i.jsx)(n.h3,{id:"trace-consumers",children:"Trace Consumers"}),"\n",(0,i.jsxs)(n.p,{children:['We are excited to introduce the innovative concept of "trace consumers" into the Cardano Tracer system. This novel approach empowers trace consumers to register with the ',(0,i.jsx)(n.code,{children:"cardano-tracer"})," application and selectively receive messages based on their subscriptions. We anticipate that this concept will significantly improve the efficiency and flexibility of our tracing system."]}),"\n",(0,i.jsx)(n.p,{children:"The introduction of trace consumers represents a robust and tailored approach to message retrieval, aligning seamlessly with the evolving needs of our network. This concept provides consumers with the ability to specify their message preferences, ensuring that they receive only the data directly relevant to their operations."}),"\n",(0,i.jsx)(n.p,{children:"As part of this development initiative, we plan to phase out the use of data points. We believe that this evolution will render data points redundant in future versions of the tracing system. The transition to trace consumers aims to streamline our data retrieval processes, eliminating the need for unnecessary data points and offering a more sophisticated and focused mechanism for trace message consumption."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>c});var i=a(6540);const r={},t=i.createContext(r);function s(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);