"use strict";(self.webpackChunknode_cli_docs=self.webpackChunknode_cli_docs||[]).push([[7405],{5365:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=a(4848),n=a(8453);const s={},o="Status",i={id:"cardano-devs/ADR/ADR-1-Default-eras-for-CLI-commands",title:"Status",description:"\u2705 Adopted  2022-12-17",source:"@site/docs/cardano-devs/ADR/ADR-1-Default-eras-for-CLI-commands.md",sourceDirName:"cardano-devs/ADR",slug:"/cardano-devs/ADR/ADR-1-Default-eras-for-CLI-commands",permalink:"/cardano-devs/ADR/ADR-1-Default-eras-for-CLI-commands",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cardano-devs/ADR/ADR-1-Default-eras-for-CLI-commands.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Status",permalink:"/cardano-devs/ADR/ADR-0-Documenting-Architecture-Decisions"},next:{title:"Status",permalink:"/cardano-devs/ADR/ADR-2-Module-structure-for-generators"}},d={},l=[];function h(e){const t={code:"code",em:"em",h1:"h1",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"status",children:"Status"}),"\n",(0,r.jsx)(t.p,{children:"\u2705 Adopted  2022-12-17"}),"\n",(0,r.jsx)(t.h1,{id:"context",children:"Context"}),"\n",(0,r.jsx)(t.p,{children:"The Cardano block chain can be hard forked through multiple eras throughout its existence.  CLI commands may behave differently between eras depending on what the current era is and what era the user runs the command in."}),"\n",(0,r.jsx)(t.p,{children:"The era to be used for a CLI command can be optional in which case the command may connect to the node to find out what the current era is and choose an era appropriately."}),"\n",(0,r.jsx)(t.p,{children:"For these cases, the question arises what the default era should be for the CLI command."}),"\n",(0,r.jsx)(t.p,{children:"Moreover there is the question of how the default era should change over time, particularly in relation to a hard fork: whether the default era should change in the release before or after the hard fork happens."}),"\n",(0,r.jsx)(t.p,{children:"There is even scope to adopt a different strategy between query and transaction commands or even between different transaction commands."}),"\n",(0,r.jsxs)(t.p,{children:["For example we can create a transaction in two different ways using the CLI - using ",(0,r.jsx)(t.code,{children:"transaction build"})," and ",(0,r.jsx)(t.code,{children:"transaction build-raw"})," commands.  The ",(0,r.jsx)(t.code,{children:"transaction build"}),' command is "magical" in that it tries to be user friendly by inferring transaction parameters wherever it can so the user doesn\'t have to, while the ',(0,r.jsx)(t.code,{children:"transaction build-raw"})," is for more experienced users because it provides no inference and leaves it up to the user to supply all the necessary transaction parameters."]}),"\n",(0,r.jsxs)(t.p,{children:['Would it make sense for "magical" commands like the ',(0,r.jsx)(t.code,{children:"transaction build"})," command to try to be more helpful and use the current era as the default?  That would ",(0,r.jsx)(t.em,{children:"seem"})," to be in the spirit of the command."]}),"\n",(0,r.jsx)(t.p,{children:"Historically we changed the default transactions era in the first release after the hard fork in order to give the tool/dapp developers the possibility to update the default transaction era in their code after the hard fork - otherwise their tools would stop working after the hard fork."}),"\n",(0,r.jsx)(t.p,{children:"Care needs to be taken to avoid making a CLI release that does not work by default by defaulting to using an era that is not yet active. So that's why we have historically only updated the default era in the release after the hard fork, not the release before."}),"\n",(0,r.jsx)(t.p,{children:"This way, third party tools that use the CLI would not stop working after the hard fork, they would continue to create and submit transactions in the older format, for the older era. Historically we always made that backwards compatibility work. It just meant that CLI users would not get the new features for the new era without explicitly using the right era flag - until the following release changed the default."}),"\n",(0,r.jsx)(t.p,{children:'Moreover, it is often the case that CLI commands in the release that crossed the hard fork may not yet be updated to work in the new era.  If we adopted policy of using the current era for our CLI commands, even "magical" commands that try to infer as much as possible, we risk possibility of the command breaking after the hard fork.'}),"\n",(0,r.jsx)(t.p,{children:"The decision should as much as possible take into account the following considerations:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"CLI behaviour should not suddenly change after a hard fork in a way that can break third party tools and user expectations."}),"\n",(0,r.jsx)(t.li,{children:"Historical precedent so as to avoid surprising SPOs and in a new release."}),"\n",(0,r.jsx)(t.li,{children:"Simplicity and consistency."}),"\n",(0,r.jsx)(t.li,{children:"Behaviour that just works where it makes sense."}),"\n"]}),"\n",(0,r.jsx)(t.h1,{id:"decision",children:"Decision"}),"\n",(0,r.jsx)(t.p,{children:"All era-sensitive CLI commands should have a default era and the default era should be consistent across all commands."}),"\n",(0,r.jsx)(t.p,{children:"A given release should use the current era up until the latest era supported by the Mainnet blockchain as at the point of release as the default era."}),"\n",(0,r.jsx)(t.p,{children:"For example, given the hard fork from Alonzo to Babbage:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The release immediately before the hard fork will set the default era to be the current era up to the Alonzo era only.  The Babbage era will not be used unless it is explicitly specified."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The release after the hard fork will use the current era up until Babbage era."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h1,{id:"consequences",children:"Consequences"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"CLI commands that for a given release had worked prior to a hard fork would continue to work after a hard fork."}),"\n",(0,r.jsx)(t.li,{children:"Users will not be surprised by changes in behaviour after the hard fork."}),"\n",(0,r.jsx)(t.li,{children:"Third party tools will continue to work after the hard fork."}),"\n",(0,r.jsx)(t.li,{children:"Users will not be surprised by difference in behaviour between different commands."}),"\n",(0,r.jsx)(t.li,{children:"Users will not necessarily be using the current era by default."}),"\n",(0,r.jsx)(t.li,{children:"Users will be using a most practical current era by default on Mainnet and other networks that may not be on the same era as Mainnet."}),"\n",(0,r.jsx)(t.li,{children:"Users will need to explicitly specify the current era after a hard fork and before the release immediately following the hard for if that's what they really want and at their own risk."}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>i});var r=a(6540);const n={},s=r.createContext(n);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);