"use strict";(self.webpackChunknode_cli_docs=self.webpackChunknode_cli_docs||[]).push([[7393],{2235:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>d});var s=i(4848),l=i(8453);const t={},a="Haskell Style Guide",o={id:"cardano-devs/contributing/Style-guide",title:"Haskell Style Guide",description:"This style guide is mostly a copy of Johan Tibell's guide",source:"@site/docs/cardano-devs/contributing/Style-guide.md",sourceDirName:"cardano-devs/contributing",slug:"/cardano-devs/contributing/Style-guide",permalink:"/documentation/cardano-devs/contributing/Style-guide",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cardano-devs/contributing/Style-guide.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Running-tests",permalink:"/documentation/cardano-devs/contributing/Running-tests"}},r={},d=[{value:"Principles",id:"principles",level:2},{value:"General guide lines",id:"general-guide-lines",level:2},{value:"Code linting and formatting tools",id:"code-linting-and-formatting-tools",level:3},{value:"Line Length",id:"line-length",level:3},{value:"Indentation",id:"indentation",level:3},{value:"Blank Lines",id:"blank-lines",level:3},{value:"Whitespace",id:"whitespace",level:3},{value:"Naming convention",id:"naming-convention",level:3},{value:"Comments",id:"comments",level:3},{value:"Punctuation",id:"punctuation",level:4},{value:"Top-Level Definitions",id:"top-level-definitions",level:4},{value:"End-of-Line Comments",id:"end-of-line-comments",level:4},{value:"Links",id:"links",level:4},{value:"Top-down guideline",id:"top-down-guideline",level:2},{value:"LANGUAGE extensions section",id:"language-extensions-section",level:3},{value:"Module name",id:"module-name",level:3},{value:"Export Lists",id:"export-lists",level:3},{value:"Imports",id:"imports",level:3},{value:"Data Declarations",id:"data-declarations",level:3},{value:"Function declaration",id:"function-declaration",level:3},{value:"List Declarations",id:"list-declarations",level:3},{value:"If-then-else clauses",id:"if-then-else-clauses",level:3},{value:"Case expressions",id:"case-expressions",level:3},{value:"Dealing with laziness",id:"dealing-with-laziness",level:2},{value:"Data types",id:"data-types",level:3},{value:"Misc",id:"misc",level:2},{value:"Multi-line string literals",id:"multi-line-string-literals",level:3},{value:"Point-free style",id:"point-free-style",level:3},{value:"Cabal file formatting",id:"cabal-file-formatting",level:2},{value:"Modules &amp; libraries",id:"modules--libraries",level:3},{value:"Warnings",id:"warnings",level:3},{value:"Default extensions",id:"default-extensions",level:3},{value:"Language Extensions to avoid",id:"language-extensions-to-avoid",level:2},{value:"OPTIONS_GHC pragma to avoid",id:"options_ghc-pragma-to-avoid",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"haskell-style-guide",children:"Haskell Style Guide"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["This style guide is mostly a copy of ",(0,s.jsx)(n.a,{href:"https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md",children:"Johan Tibell's guide"}),"\nwith some restructurization, elaboration on some topics and some additions.\nThis style guide's aims are code beauty, readability and understandability."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"principles",children:"Principles"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The primary goal is readability/maintainability with performance as a close second."}),"\n",(0,s.jsx)(n.li,{children:"Always use types to clarify intent and make invalid states unrepresentable."}),"\n",(0,s.jsx)(n.li,{children:"Use type signatures as compiler checked documentation."}),"\n",(0,s.jsx)(n.li,{children:"Break up large functions into smaller sub functions."}),"\n",(0,s.jsx)(n.li,{children:"When modifying or adding code to existing code (either at the file, project or company level), try to match the style of the existing code."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"general-guide-lines",children:"General guide lines"}),"\n",(0,s.jsx)(n.h3,{id:"code-linting-and-formatting-tools",children:"Code linting and formatting tools"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"stylish-haskell"})," is used for automatic code formatting and ",(0,s.jsx)(n.code,{children:"hlint"})," for linting.\nThose are configured using ",(0,s.jsx)(n.code,{children:".stylish-haskell.yml"})," and ",(0,s.jsx)(n.code,{children:".hlint.yml"})," files in the repository root.\nIf you would like to check your changes before committing them, you can use the following ",(0,s.jsxs)(n.a,{href:"https://github.com/intersectmbo/cardano-node/blob/master/scripts/githooks/haskell-style-lint",children:[(0,s.jsx)(n.code,{children:".git/hooks/pre-commit"})," hook"]}),".\nIt requires ",(0,s.jsx)(n.code,{children:"stylish-haskell"})," and ",(0,s.jsx)(n.code,{children:"hlint"})," to be available in ",(0,s.jsx)(n.code,{children:"$PATH"})," and runs against the staged files."]}),"\n",(0,s.jsx)(n.h3,{id:"line-length",children:"Line Length"}),"\n",(0,s.jsxs)(n.p,{children:["Maximum line length is ",(0,s.jsx)(n.em,{children:"80 characters"})," or ",(0,s.jsx)(n.em,{children:"100 characters"})," if necessary."]}),"\n",(0,s.jsxs)(n.p,{children:["Modern screens have high definition and big width.\nBut with some tiling managers and two terminals on one screen you are not able to\nsee many characters on one line.\nOn the other hand, restricting line size to a very small number like 80 leads to\nsome crazy indentation despite the fact that\nshorter lines should force you to write well structured code.\nThat's why ",(0,s.jsx)(n.em,{children:"100"})," is a reasonable compromise."]}),"\n",(0,s.jsx)(n.h3,{id:"indentation",children:"Indentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Do not vertically align code. Mainly because the need to change identifiers and re-aligning the other lines causes semantically null changes in the diff."}),"\n",(0,s.jsx)(n.li,{children:"Tabs are illegal."}),"\n",(0,s.jsx)(n.li,{children:"Use spaces for indenting."}),"\n",(0,s.jsxs)(n.li,{children:["Indent your code blocks with ",(0,s.jsx)(n.em,{children:"2 spaces"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Indent the ",(0,s.jsx)(n.code,{children:"where"})," keyword with one space to set it\napart from the rest of the code and indent the definitions in a\n",(0,s.jsx)(n.code,{children:"where"})," clause with 1 space."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Some examples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:'sayHello :: IO ()\nsayHello = do\n  name <- getLine\n  putStrLn $ greeting name\n where\n  greeting :: String -> String\n  greeting name = "Hello, " ++ name ++ "!"\n\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter _ [] = []\nfilter p (x:xs)\n  | p x = x : filter p xs\n  | otherwise = filter p xs\n'})}),"\n",(0,s.jsx)(n.h3,{id:"blank-lines",children:"Blank Lines"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"One blank line between top-level definitions."}),"\n",(0,s.jsx)(n.li,{children:"No blank lines between type signatures and function definitions."}),"\n",(0,s.jsx)(n.li,{children:"Add one blank line between\nfunctions in a type class instance declaration if the function bodies\nare large."}),"\n",(0,s.jsxs)(n.li,{children:["You can add blank lines inside a big ",(0,s.jsx)(n.code,{children:"do"})," block to separate logical\nparts of it."]}),"\n",(0,s.jsxs)(n.li,{children:["You can also use blank lines to separate definitions inside ",(0,s.jsx)(n.code,{children:"where"}),"\nclause, if necessary."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"whitespace",children:"Whitespace"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Surround binary operators with a single space on either side. In case of\ncurrying add one space between the argument and the operation."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Use some tool to remove trailing spaces."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"naming-convention",children:"Naming convention"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Casing"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"lowerCamelCase"})})," for function and variable names."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"UpperCamelCase"})})," for types."]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Don't use short names like ",(0,s.jsx)(n.code,{children:"n"}),", ",(0,s.jsx)(n.code,{children:"sk"}),", ",(0,s.jsx)(n.code,{children:"f"})," unless their meaning is clear from\ncontext (function name, types, other variables, etc.)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["For readability reasons, don't capitalize all letters when using an\nabbreviation.  For example, write ",(0,s.jsx)(n.code,{children:"HttpServer"})," instead of\n",(0,s.jsx)(n.code,{children:"HTTPServer"}),".  Exception: two or three letter abbreviations, e.g. ",(0,s.jsx)(n.code,{children:"IO"}),", ",(0,s.jsx)(n.code,{children:"STM"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Records name conventions"})}),"\n",(0,s.jsxs)(n.p,{children:["If data type has only one constructor then this data type name should be the same\nas constructor name (also applies to ",(0,s.jsx)(n.code,{children:"newtype"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data User = User Int String\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Field names for record data types"})}),"\n",(0,s.jsx)(n.p,{children:"Choose a reasonable prefix is used such that we can ensure the field name will remain unique throughout the package. Use your discretion."}),"\n",(0,s.jsx)(n.p,{children:"e.g"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data MempoolEnv m blk = MempoolEnv\n  { meLedger :: LedgerInterface m blk\n  , meLedgerCfg :: LedgerConfig blk\n  , meStateVar :: StrictTVar m (InternalState blk)\n  , meTracer :: Tracer m (TraceEventMempool blk)\n  }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"comments",children:"Comments"}),"\n",(0,s.jsx)(n.h4,{id:"punctuation",children:"Punctuation"}),"\n",(0,s.jsx)(n.p,{children:"Write proper sentences; start with a capital letter and use proper\npunctuation."}),"\n",(0,s.jsx)(n.h4,{id:"top-level-definitions",children:"Top-Level Definitions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Comment top level functions (particularly exported functions)\nas much as possible. If it is not blindingly obvious what a function\nis doing, you should add a comment."}),"\n",(0,s.jsx)(n.li,{children:"Always provide a type signature"}),"\n",(0,s.jsx)(n.li,{children:"Use Haddock syntax in the comments."}),"\n",(0,s.jsx)(n.li,{children:"Comment every exported data type."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Function example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"-- | Send a message on a socket. The socket must be in a connected\n-- state. Returns the number of bytes sent. Applications are\n-- responsible for ensuring that all data has been sent.\nsend\n  :: Socket      -- ^ Connected socket\n  -> ByteString  -- ^ Data to send\n  -> IO Int      -- ^ Bytes sent\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For functions, the documentation should give enough information to\napply the function without looking at its definition."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Record example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"-- | Bla bla bla.\ndata Person = Person\n  { age :: !Int     -- ^ Age\n  , name :: !String  -- ^ First name\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"For fields that require longer comments, format them this way:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data Record = Record\n  { -- | This is a very very very long comment that is split over\n    -- multiple lines.\n    field1 :: !Text\n\n    -- | This is a second very very very long comment that is split\n    -- over multiple lines.\n  , field2 :: !Int\n  }\n"})}),"\n",(0,s.jsx)(n.h4,{id:"end-of-line-comments",children:"End-of-Line Comments"}),"\n",(0,s.jsx)(n.p,{children:"Separate end-of-line comments from the code with 2 spaces. Align\ncomments for data type definitions. Some examples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data Parser =\n  Parser\n    !Int         -- ^ Current position\n    !ByteString  -- ^ Remaining input\n\nfoo :: Int -> Int\nfoo n = salt * 32 + 9\n  where\n    salt = 453645243  -- Magic hash salt.\n"})}),"\n",(0,s.jsx)(n.h4,{id:"links",children:"Links"}),"\n",(0,s.jsx)(n.p,{children:"Use in-line links economically.  You are encouraged to add links for\nAPI names. It is not necessary to add links for all API names in a\nHaddock comment. We therefore recommend adding a link to an API name\nif:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The user might actually want to click on it for more information (in\nyour opinion), and"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Only for the first occurrence of each API name in the comment (don't\nbother repeating a link)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"top-down-guideline",children:"Top-down guideline"}),"\n",(0,s.jsx)(n.h3,{id:"language-extensions-section",children:"LANGUAGE extensions section"}),"\n",(0,s.jsxs)(n.p,{children:["Write each ",(0,s.jsx)(n.code,{children:"LANGUAGE"})," pragma on its own line, sort them alphabetically.\n",(0,s.jsx)(n.em,{children:"Do not"})," align by max width as future re-alignment when adding new pragmas\nwill cause semantically null changes in the diff."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE TemplateHaskell #-}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"module-name",children:"Module name"}),"\n",(0,s.jsxs)(n.p,{children:["Use singular when naming modules (e.g. use ",(0,s.jsx)(n.code,{children:"Data.Map"})," and\n",(0,s.jsx)(n.code,{children:"Data.ByteString.Internal"})," instead of ",(0,s.jsx)(n.code,{children:"Data.Maps"})," and\n",(0,s.jsx)(n.code,{children:"Data.ByteString.Internals"}),"). Sometimes it's acceptable to use plural\n(e. g. ",(0,s.jsx)(n.code,{children:"Types"}),", ",(0,s.jsx)(n.code,{children:"Instances"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"export-lists",children:"Export Lists"}),"\n",(0,s.jsx)(n.p,{children:"Format export lists as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"module Data.Set\n  ( Set\n  , empty\n  , singleton\n  , member\n  ) where\n"})}),"\n",(0,s.jsx)(n.p,{children:"Some clarifications:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Use 2 spaces indentation for export list."}),"\n",(0,s.jsx)(n.li,{children:"You can split export list into sections or just write all as single section."}),"\n",(0,s.jsx)(n.li,{children:"It is strongly advised to sort each section alphabetically. However,\nclasses, data types and type aliases should be written before\nfunctions."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"imports",children:"Imports"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For external modules, use explicit or ",(0,s.jsx)(n.code,{children:"qualified"})," imports."]}),"\n",(0,s.jsx)(n.li,{children:"For local modules, use implicit imports."}),"\n",(0,s.jsxs)(n.li,{children:["Always use explicit import lists or ",(0,s.jsx)(n.code,{children:"qualified"})," imports.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exception"}),":\n",(0,s.jsx)(n.a,{href:"https://github.com/intersectmbo/cardano-prelude",children:(0,s.jsx)(n.code,{children:"cardano-prelude"})})," (import implicitly)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.code,{children:"import"})," is unqualified then put ",(0,s.jsx)(n.em,{children:"11 spaces"})," between the ",(0,s.jsx)(n.code,{children:"import"})," keyword and the module name (i.e. length of ",(0,s.jsx)(n.code,{children:"qualified"})," + 2)."]}),"\n",(0,s.jsxs)(n.p,{children:["Unqualified types (i.e. ",(0,s.jsx)(n.code,{children:"Map"})," vs. ",(0,s.jsx)(n.code,{children:"M.Map"}),") look pretty good and not so ugly.\nPrefer two-line imports for such standard containers."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"import           Data.Map.Strict (Map)\nimport qualified Data.Map.Strict as Map\n"})}),"\n",(0,s.jsx)(n.h3,{id:"data-declarations",children:"Data Declarations"}),"\n",(0,s.jsx)(n.p,{children:"Align the constructors in a data type definition.  Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data HttpException\n  = InvalidStatusCode Int\n  | MissingContentHeader\n"})}),"\n",(0,s.jsx)(n.p,{children:"Format records as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data Person = Person\n  { firstName :: !String  -- ^ First name\n  , lastName :: !String  -- ^ Last name\n  , age :: !Int     -- ^ Age\n  } deriving (Eq, Show)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Type classes in ",(0,s.jsx)(n.code,{children:"deriving"})," section should be always surrounded by\nparentheses."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"WARNING"}),": try to avoid aggressive autoderiving. Deriving instances can\nslowdown compilation\n(stated here: ",(0,s.jsx)(n.a,{href:"http://www.stephendiehl.com/posts/production.html",children:"http://www.stephendiehl.com/posts/production.html"}),")"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Deriving instances of Read/Show/Data/Generic for largely recursive ADTs can\nsometimes lead to quadratic memory behavior when the nesting gets deep."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"function-declaration",children:"Function declaration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"All functions must have type signatures."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Specialize function type signature for concrete types if you're using this function\nwith only one type for each argument. Otherwise you should use more polymorphic\nversion. Compiler can optimize specialized functions better\nand meaning of this function may be clearer.\nUse this rule unless you are the library creator and want your library to be abstract\nas possible."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"It is allowed to omit parentheses for only one type class constraint."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If a function type signature is very long then place some of the types on its own line."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"putValueInState\n  :: MonadIO m\n  => UserState -> Maybe Int -> AppConfig\n  -> Integer -> (Int -> m ()) -> m ()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"list-declarations",children:"List Declarations"}),"\n",(0,s.jsx)(n.p,{children:"Align the elements in the list.  Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"exceptions =\n  [ InvalidStatusCode\n  , MissingContentHeader\n  , InternalServerError\n  ]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"if-then-else-clauses",children:"If-then-else clauses"}),"\n",(0,s.jsxs)(n.p,{children:["Generally, guards and pattern matches should be preferred over ",(0,s.jsx)(n.em,{children:"if-then-else"}),"\nclauses, where possible.  Short cases should usually be put on a single line\n(when line length allows it)."]}),"\n",(0,s.jsx)(n.h3,{id:"case-expressions",children:"Case expressions"}),"\n",(0,s.jsx)(n.p,{children:"The alternatives in a case expression can be indented using either of\nthe two following styles:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"foobar =\n  case something of\n    Just j -> foo\n    Nothing -> bar\n"})}),"\n",(0,s.jsx)(n.p,{children:"or as"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"foobar = case something of\n           Just j -> foo\n           Nothing -> bar\n"})}),"\n",(0,s.jsx)(n.p,{children:"but not"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"foobar = case something of\n    Just j  -> foo\n    Nothing -> bar\n"})}),"\n",(0,s.jsx)(n.p,{children:"Subexpressions should always be indented to the right of their parent expression."}),"\n",(0,s.jsx)(n.h2,{id:"dealing-with-laziness",children:"Dealing with laziness"}),"\n",(0,s.jsx)(n.p,{children:"By default, use strict data types and lazy functions."}),"\n",(0,s.jsx)(n.h3,{id:"data-types",children:"Data types"}),"\n",(0,s.jsx)(n.p,{children:"Constructor fields should be strict, unless there's an explicit reason\nto make them lazy.  This helps to avoid many common pitfalls caused by too much\nlaziness and reduces the number of brain cycles the programmer has to\nspend thinking about evaluation order."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"-- Good\ndata Point = Point\n  { pointX :: !Double  -- ^ X coordinate\n  , pointY :: !Double  -- ^ Y coordinate\n  }\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"-- Bad\ndata Point = Point\n  { pointX :: Double  -- ^ X coordinate\n  , pointY :: Double  -- ^ Y coordinate\n  }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"misc",children:"Misc"}),"\n",(0,s.jsx)(n.h3,{id:"multi-line-string-literals",children:"Multi-line string literals"}),"\n",(0,s.jsxs)(n.p,{children:["Multi-line string literals like this should be avoided because it can interact badly with some language extensions like ",(0,s.jsx)(n.code,{children:"CPP"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:'foo = "The quick brown fox jumps \\\n  \\over the lazy dog"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Instead do one of the following:"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"mconcat"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:'foo = mconcat\n  [ "The quick brown fox jumps "\n  , "over the lazy dog"\n  ]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The above is preferred because it makes it easy to maintain the two-space indent and allows the use of ",(0,s.jsx)(n.code,{children:"$"})," where other options do not."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:'foo = mconcat\n  [ "The quick brown fox jumps "\n  , Text.pack $ reverse "over the lazy dog"\n  ]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"(<>)"}),", keeping argument and operator aligned to two-spaces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:'foo = Text.pack\n  (   "The quick brown fox jumps "\n  <>  "over the lazy dog"\n  )\n'})}),"\n",(0,s.jsx)(n.h3,{id:"point-free-style",children:"Point-free style"}),"\n",(0,s.jsx)(n.p,{children:"Avoid over-using point-free style. Again, use your discretion."}),"\n",(0,s.jsx)(n.p,{children:"For example, this is hard to read:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"-- Bad:\nf = (g .) . h\n"})}),"\n",(0,s.jsx)(n.p,{children:"Whereas this is fine:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"unFooBar :: Foo -> Baz\nunFooBar = Baz . unBar . unFoo\n"})}),"\n",(0,s.jsx)(n.p,{children:"The point-free version needs to have a clarity benefit but we realize\nthat this is vague so use your discretion."}),"\n",(0,s.jsx)(n.h2,{id:"cabal-file-formatting",children:"Cabal file formatting"}),"\n",(0,s.jsx)(n.h3,{id:"modules--libraries",children:"Modules & libraries"}),"\n",(0,s.jsx)(n.p,{children:"Modules and libraries should go in alphabetical order inside corresponding\nsections. You can put blank lines between groups in each section."}),"\n",(0,s.jsx)(n.h3,{id:"warnings",children:"Warnings"}),"\n",(0,s.jsxs)(n.p,{children:["Code should be compilable with ",(0,s.jsx)(n.code,{children:"-Wall"})," without warnings."]}),"\n",(0,s.jsx)(n.h3,{id:"default-extensions",children:"Default extensions"}),"\n",(0,s.jsxs)(n.p,{children:["The only allowed default extension is: ",(0,s.jsx)(n.code,{children:"NoImplicitPrelude"}),"\nAll other extensions need to be put in the relevant module."]}),"\n",(0,s.jsx)(n.h2,{id:"language-extensions-to-avoid",children:"Language Extensions to avoid"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Avoid ",(0,s.jsx)(n.code,{children:"RecordWildCards"})," - use ",(0,s.jsx)(n.code,{children:"NamedFieldPuns"})," instead. ",(0,s.jsx)(n.code,{children:"RecordWildCards"})," makes it difficult to discern where record accessor functions come from, ",(0,s.jsx)(n.em,{children:"especially"})," when used with external libraries. This results in time wasted searching for the accessors. ",(0,s.jsx)(n.code,{children:"NamedFieldPuns"})," forces you to be more explicit and is a better alternative."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Avoid ",(0,s.jsx)(n.code,{children:"ViewPatterns"})," - ",(0,s.jsx)(n.code,{children:"ViewPatterns"})," obfuscates what could have been readable code and incurs more cognitive overhead."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"options_ghc-pragma-to-avoid",children:"OPTIONS_GHC pragma to avoid"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-Wno-incomplete-uni-patterns"})," - This a bad idea. GHC will not warn you if you have not explicitly handled all possible cases in your function definitions. This opens up the possibility of a runtime error."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-Wno-partial-fields"})," - This will allow you to define a partial record accessor which opens you up to the possibility of a runtime error."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const l={},t=s.createContext(l);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);